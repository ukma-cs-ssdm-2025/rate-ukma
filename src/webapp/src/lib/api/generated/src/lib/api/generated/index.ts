/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * Rate UKMA API
 * An API for rating UKMA courses and professors
 * OpenAPI spec version: 1.0.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseInfiniteQueryResult,
	DefinedUseQueryResult,
	InfiniteData,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseInfiniteQueryOptions,
	UseInfiniteQueryResult,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";

import type {
	Course,
	CourseListResponse,
	CoursesListParams,
	ErrorEnvelope,
	Login,
	PatchedRating,
	Rating,
	Session,
} from "./models";

import { authorizedFetcher } from "../../../../../apiClient";

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
	T,
>() => T extends Y ? 1 : 2
	? A
	: B;

type WritableKeys<T> = {
	[P in keyof T]-?: IfEquals<
		{ [Q in P]: T[P] },
		{ -readonly [Q in P]: T[P] },
		P
	>;
}[keyof T];

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
	k: infer I,
) => void
	? I
	: never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
	? {
			[P in keyof Writable<T>]: T[P] extends object
				? NonReadonly<NonNullable<T[P]>>
				: T[P];
		}
	: DistributeReadOnlyOverUnions<T>;

/**
 * Logs in user using Django authentication flow. Version: v1.
 * @summary Django Login
 */
export const authLoginCreate = (login: Login, signal?: AbortSignal) => {
	return authorizedFetcher<void>({
		url: `/api/v1/auth/login/`,
		method: "POST",
		headers: { "Content-Type": "application/json" },
		data: login,
		signal,
	});
};

export const getAuthLoginCreateMutationOptions = <
	TError = ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof authLoginCreate>>,
		TError,
		{ data: Login },
		TContext
	>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof authLoginCreate>>,
	TError,
	{ data: Login },
	TContext
> => {
	const mutationKey = ["authLoginCreate"];
	const { mutation: mutationOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof authLoginCreate>>,
		{ data: Login }
	> = (props) => {
		const { data } = props ?? {};

		return authLoginCreate(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type AuthLoginCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof authLoginCreate>>
>;
export type AuthLoginCreateMutationBody = Login;
export type AuthLoginCreateMutationError = ErrorEnvelope | ErrorEnvelope;

/**
 * @summary Django Login
 */
export const useAuthLoginCreate = <
	TError = ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof authLoginCreate>>,
			TError,
			{ data: Login },
			TContext
		>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof authLoginCreate>>,
	TError,
	{ data: Login },
	TContext
> => {
	const mutationOptions = getAuthLoginCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * Initiates Microsoft OAuth2 authentication flow. Redirects to Microsoft login page for @ukma.edu.ua accounts. Backend handles session authentication and redirects to frontend. Version: v1.
 * @summary Microsoft OAuth Login
 */
export const authLoginMicrosoftRetrieve = (signal?: AbortSignal) => {
	return authorizedFetcher<unknown>({
		url: `/api/v1/auth/login/microsoft/`,
		method: "GET",
		signal,
	});
};

export const getAuthLoginMicrosoftRetrieveQueryKey = () => {
	return [`/api/v1/auth/login/microsoft/`] as const;
};

export const getAuthLoginMicrosoftRetrieveQueryOptions = <
	TData = Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
	TError = void | ErrorEnvelope | ErrorEnvelope,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
			TError,
			TData
		>
	>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getAuthLoginMicrosoftRetrieveQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>
	> = ({ signal }) => authLoginMicrosoftRetrieve(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthLoginMicrosoftRetrieveQueryResult = NonNullable<
	Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>
>;
export type AuthLoginMicrosoftRetrieveQueryError =
	| void
	| ErrorEnvelope
	| ErrorEnvelope;

export function useAuthLoginMicrosoftRetrieve<
	TData = Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
	TError = void | ErrorEnvelope | ErrorEnvelope,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
					TError,
					Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthLoginMicrosoftRetrieve<
	TData = Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
	TError = void | ErrorEnvelope | ErrorEnvelope,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
					TError,
					Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthLoginMicrosoftRetrieve<
	TData = Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
	TError = void | ErrorEnvelope | ErrorEnvelope,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Microsoft OAuth Login
 */

export function useAuthLoginMicrosoftRetrieve<
	TData = Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
	TError = void | ErrorEnvelope | ErrorEnvelope,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authLoginMicrosoftRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getAuthLoginMicrosoftRetrieveQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Logs out current user and redirects to the configured logout URL. Version: v1.
 * @summary Logout
 */
export const authLogoutCreate = (signal?: AbortSignal) => {
	return authorizedFetcher<unknown>({
		url: `/api/v1/auth/logout/`,
		method: "POST",
		signal,
	});
};

export const getAuthLogoutCreateMutationOptions = <
	TError = void | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof authLogoutCreate>>,
		TError,
		void,
		TContext
	>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof authLogoutCreate>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ["authLogoutCreate"];
	const { mutation: mutationOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof authLogoutCreate>>,
		void
	> = () => {
		return authLogoutCreate();
	};

	return { mutationFn, ...mutationOptions };
};

export type AuthLogoutCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof authLogoutCreate>>
>;

export type AuthLogoutCreateMutationError =
	| void
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

/**
 * @summary Logout
 */
export const useAuthLogoutCreate = <
	TError = void | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof authLogoutCreate>>,
			TError,
			void,
			TContext
		>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof authLogoutCreate>>,
	TError,
	void,
	TContext
> => {
	const mutationOptions = getAuthLogoutCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * Returns current authentication session information. Responds with 200 and user data when authenticated, or 401 when no active session. Version: v1.
 * @summary Session state
 */
export const authSessionRetrieve = (signal?: AbortSignal) => {
	return authorizedFetcher<Session>({
		url: `/api/v1/auth/session/`,
		method: "GET",
		signal,
	});
};

export const getAuthSessionRetrieveQueryKey = () => {
	return [`/api/v1/auth/session/`] as const;
};

export const getAuthSessionRetrieveQueryOptions = <
	TData = Awaited<ReturnType<typeof authSessionRetrieve>>,
	TError = ErrorEnvelope,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof authSessionRetrieve>>,
			TError,
			TData
		>
	>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAuthSessionRetrieveQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof authSessionRetrieve>>
	> = ({ signal }) => authSessionRetrieve(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof authSessionRetrieve>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthSessionRetrieveQueryResult = NonNullable<
	Awaited<ReturnType<typeof authSessionRetrieve>>
>;
export type AuthSessionRetrieveQueryError = ErrorEnvelope;

export function useAuthSessionRetrieve<
	TData = Awaited<ReturnType<typeof authSessionRetrieve>>,
	TError = ErrorEnvelope,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authSessionRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof authSessionRetrieve>>,
					TError,
					Awaited<ReturnType<typeof authSessionRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthSessionRetrieve<
	TData = Awaited<ReturnType<typeof authSessionRetrieve>>,
	TError = ErrorEnvelope,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authSessionRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof authSessionRetrieve>>,
					TError,
					Awaited<ReturnType<typeof authSessionRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthSessionRetrieve<
	TData = Awaited<ReturnType<typeof authSessionRetrieve>>,
	TError = ErrorEnvelope,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authSessionRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Session state
 */

export function useAuthSessionRetrieve<
	TData = Awaited<ReturnType<typeof authSessionRetrieve>>,
	TError = ErrorEnvelope,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authSessionRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getAuthSessionRetrieveQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Returns a paginated list of courses with filters. Version: v1.
 * @summary List courses (mock)
 */
export const coursesList = (
	params?: CoursesListParams,
	signal?: AbortSignal,
) => {
	return authorizedFetcher<CourseListResponse>({
		url: `/api/v1/courses/`,
		method: "GET",
		params,
		signal,
	});
};

export const getCoursesListInfiniteQueryKey = (params?: CoursesListParams) => {
	return ["infinate", `/api/v1/courses/`, ...(params ? [params] : [])] as const;
};

export const getCoursesListQueryKey = (params?: CoursesListParams) => {
	return [`/api/v1/courses/`, ...(params ? [params] : [])] as const;
};

export const getCoursesListInfiniteQueryOptions = <
	TData = InfiniteData<
		Awaited<ReturnType<typeof coursesList>>,
		CoursesListParams["page"]
	>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof coursesList>>,
				TError,
				TData,
				QueryKey,
				CoursesListParams["page"]
			>
		>;
	},
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getCoursesListInfiniteQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof coursesList>>,
		QueryKey,
		CoursesListParams["page"]
	> = ({ signal, pageParam }) =>
		coursesList({ ...params, page: pageParam || params?.["page"] }, signal);

	return { queryKey, queryFn, ...queryOptions } as UseInfiniteQueryOptions<
		Awaited<ReturnType<typeof coursesList>>,
		TError,
		TData,
		QueryKey,
		CoursesListParams["page"]
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CoursesListInfiniteQueryResult = NonNullable<
	Awaited<ReturnType<typeof coursesList>>
>;
export type CoursesListInfiniteQueryError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

export function useCoursesListInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof coursesList>>,
		CoursesListParams["page"]
	>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params: undefined | CoursesListParams,
	options: {
		query: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof coursesList>>,
				TError,
				TData,
				QueryKey,
				CoursesListParams["page"]
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof coursesList>>,
					TError,
					Awaited<ReturnType<typeof coursesList>>,
					QueryKey
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCoursesListInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof coursesList>>,
		CoursesListParams["page"]
	>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof coursesList>>,
				TError,
				TData,
				QueryKey,
				CoursesListParams["page"]
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof coursesList>>,
					TError,
					Awaited<ReturnType<typeof coursesList>>,
					QueryKey
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCoursesListInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof coursesList>>,
		CoursesListParams["page"]
	>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof coursesList>>,
				TError,
				TData,
				QueryKey,
				CoursesListParams["page"]
			>
		>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List courses (mock)
 */

export function useCoursesListInfinite<
	TData = InfiniteData<
		Awaited<ReturnType<typeof coursesList>>,
		CoursesListParams["page"]
	>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseInfiniteQueryOptions<
				Awaited<ReturnType<typeof coursesList>>,
				TError,
				TData,
				QueryKey,
				CoursesListParams["page"]
			>
		>;
	},
	queryClient?: QueryClient,
): UseInfiniteQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getCoursesListInfiniteQueryOptions(params, options);

	const query = useInfiniteQuery(
		queryOptions,
		queryClient,
	) as UseInfiniteQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getCoursesListQueryOptions = <
	TData = Awaited<ReturnType<typeof coursesList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof coursesList>>, TError, TData>
		>;
	},
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getCoursesListQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof coursesList>>> = ({
		signal,
	}) => coursesList(params, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof coursesList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CoursesListQueryResult = NonNullable<
	Awaited<ReturnType<typeof coursesList>>
>;
export type CoursesListQueryError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

export function useCoursesList<
	TData = Awaited<ReturnType<typeof coursesList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params: undefined | CoursesListParams,
	options: {
		query: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof coursesList>>, TError, TData>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof coursesList>>,
					TError,
					Awaited<ReturnType<typeof coursesList>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCoursesList<
	TData = Awaited<ReturnType<typeof coursesList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof coursesList>>, TError, TData>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof coursesList>>,
					TError,
					Awaited<ReturnType<typeof coursesList>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCoursesList<
	TData = Awaited<ReturnType<typeof coursesList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof coursesList>>, TError, TData>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List courses (mock)
 */

export function useCoursesList<
	TData = Awaited<ReturnType<typeof coursesList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	params?: CoursesListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<Awaited<ReturnType<typeof coursesList>>, TError, TData>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getCoursesListQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Returns a single course by ID. Version: v1.
 * @summary Get course by ID (mock)
 */
export const coursesRetrieve = (courseId: string, signal?: AbortSignal) => {
	return authorizedFetcher<Course>({
		url: `/api/v1/courses/${courseId}/`,
		method: "GET",
		signal,
	});
};

export const getCoursesRetrieveQueryKey = (courseId?: string) => {
	return [`/api/v1/courses/${courseId}/`] as const;
};

export const getCoursesRetrieveQueryOptions = <
	TData = Awaited<ReturnType<typeof coursesRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof coursesRetrieve>>,
				TError,
				TData
			>
		>;
	},
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getCoursesRetrieveQueryKey(courseId);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof coursesRetrieve>>> = ({
		signal,
	}) => coursesRetrieve(courseId, signal);

	return {
		queryKey,
		queryFn,
		enabled: !!courseId,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof coursesRetrieve>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CoursesRetrieveQueryResult = NonNullable<
	Awaited<ReturnType<typeof coursesRetrieve>>
>;
export type CoursesRetrieveQueryError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

export function useCoursesRetrieve<
	TData = Awaited<ReturnType<typeof coursesRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof coursesRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof coursesRetrieve>>,
					TError,
					Awaited<ReturnType<typeof coursesRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCoursesRetrieve<
	TData = Awaited<ReturnType<typeof coursesRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof coursesRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof coursesRetrieve>>,
					TError,
					Awaited<ReturnType<typeof coursesRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCoursesRetrieve<
	TData = Awaited<ReturnType<typeof coursesRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof coursesRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get course by ID (mock)
 */

export function useCoursesRetrieve<
	TData = Awaited<ReturnType<typeof coursesRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof coursesRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getCoursesRetrieveQueryOptions(courseId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary List ratings for a course (mock)
 */
export const courseRatingsList = (courseId: string, signal?: AbortSignal) => {
	return authorizedFetcher<Rating[]>({
		url: `/api/v1/courses/${courseId}/ratings/`,
		method: "GET",
		signal,
	});
};

export const getCourseRatingsListQueryKey = (courseId?: string) => {
	return [`/api/v1/courses/${courseId}/ratings/`] as const;
};

export const getCourseRatingsListQueryOptions = <
	TData = Awaited<ReturnType<typeof courseRatingsList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingsList>>,
				TError,
				TData
			>
		>;
	},
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getCourseRatingsListQueryKey(courseId);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof courseRatingsList>>
	> = ({ signal }) => courseRatingsList(courseId, signal);

	return {
		queryKey,
		queryFn,
		enabled: !!courseId,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof courseRatingsList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CourseRatingsListQueryResult = NonNullable<
	Awaited<ReturnType<typeof courseRatingsList>>
>;
export type CourseRatingsListQueryError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

export function useCourseRatingsList<
	TData = Awaited<ReturnType<typeof courseRatingsList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingsList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof courseRatingsList>>,
					TError,
					Awaited<ReturnType<typeof courseRatingsList>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCourseRatingsList<
	TData = Awaited<ReturnType<typeof courseRatingsList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingsList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof courseRatingsList>>,
					TError,
					Awaited<ReturnType<typeof courseRatingsList>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCourseRatingsList<
	TData = Awaited<ReturnType<typeof courseRatingsList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingsList>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List ratings for a course (mock)
 */

export function useCourseRatingsList<
	TData = Awaited<ReturnType<typeof courseRatingsList>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingsList>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getCourseRatingsListQueryOptions(courseId, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Create rating for a course (mock)
 */
export const courseRatingsCreate = (
	courseId: string,
	rating: NonReadonly<Rating>,
	signal?: AbortSignal,
) => {
	return authorizedFetcher<Rating>({
		url: `/api/v1/courses/${courseId}/ratings/`,
		method: "POST",
		headers: { "Content-Type": "application/json" },
		data: rating,
		signal,
	});
};

export const getCourseRatingsCreateMutationOptions = <
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof courseRatingsCreate>>,
		TError,
		{ courseId: string; data: NonReadonly<Rating> },
		TContext
	>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof courseRatingsCreate>>,
	TError,
	{ courseId: string; data: NonReadonly<Rating> },
	TContext
> => {
	const mutationKey = ["courseRatingsCreate"];
	const { mutation: mutationOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof courseRatingsCreate>>,
		{ courseId: string; data: NonReadonly<Rating> }
	> = (props) => {
		const { courseId, data } = props ?? {};

		return courseRatingsCreate(courseId, data);
	};

	return { mutationFn, ...mutationOptions };
};

export type CourseRatingsCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof courseRatingsCreate>>
>;
export type CourseRatingsCreateMutationBody = NonReadonly<Rating>;
export type CourseRatingsCreateMutationError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

/**
 * @summary Create rating for a course (mock)
 */
export const useCourseRatingsCreate = <
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof courseRatingsCreate>>,
			TError,
			{ courseId: string; data: NonReadonly<Rating> },
			TContext
		>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof courseRatingsCreate>>,
	TError,
	{ courseId: string; data: NonReadonly<Rating> },
	TContext
> => {
	const mutationOptions = getCourseRatingsCreateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Retrieve rating for a course (mock)
 */
export const courseRatingRetrieve = (
	courseId: string,
	ratingId: string,
	signal?: AbortSignal,
) => {
	return authorizedFetcher<Rating>({
		url: `/api/v1/courses/${courseId}/ratings/${ratingId}/`,
		method: "GET",
		signal,
	});
};

export const getCourseRatingRetrieveQueryKey = (
	courseId?: string,
	ratingId?: string,
) => {
	return [`/api/v1/courses/${courseId}/ratings/${ratingId}/`] as const;
};

export const getCourseRatingRetrieveQueryOptions = <
	TData = Awaited<ReturnType<typeof courseRatingRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	ratingId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingRetrieve>>,
				TError,
				TData
			>
		>;
	},
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getCourseRatingRetrieveQueryKey(courseId, ratingId);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof courseRatingRetrieve>>
	> = ({ signal }) => courseRatingRetrieve(courseId, ratingId, signal);

	return {
		queryKey,
		queryFn,
		enabled: !!(courseId && ratingId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof courseRatingRetrieve>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type CourseRatingRetrieveQueryResult = NonNullable<
	Awaited<ReturnType<typeof courseRatingRetrieve>>
>;
export type CourseRatingRetrieveQueryError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

export function useCourseRatingRetrieve<
	TData = Awaited<ReturnType<typeof courseRatingRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	ratingId: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof courseRatingRetrieve>>,
					TError,
					Awaited<ReturnType<typeof courseRatingRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCourseRatingRetrieve<
	TData = Awaited<ReturnType<typeof courseRatingRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	ratingId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingRetrieve>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof courseRatingRetrieve>>,
					TError,
					Awaited<ReturnType<typeof courseRatingRetrieve>>
				>,
				"initialData"
			>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useCourseRatingRetrieve<
	TData = Awaited<ReturnType<typeof courseRatingRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	ratingId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Retrieve rating for a course (mock)
 */

export function useCourseRatingRetrieve<
	TData = Awaited<ReturnType<typeof courseRatingRetrieve>>,
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
>(
	courseId: string,
	ratingId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof courseRatingRetrieve>>,
				TError,
				TData
			>
		>;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getCourseRatingRetrieveQueryOptions(
		courseId,
		ratingId,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update rating for a course (mock)
 */
export const courseRatingUpdate = (
	courseId: string,
	ratingId: string,
	patchedRating: NonReadonly<PatchedRating>,
) => {
	return authorizedFetcher<Rating>({
		url: `/api/v1/courses/${courseId}/ratings/${ratingId}/`,
		method: "PATCH",
		headers: { "Content-Type": "application/json" },
		data: patchedRating,
	});
};

export const getCourseRatingUpdateMutationOptions = <
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof courseRatingUpdate>>,
		TError,
		{ courseId: string; ratingId: string; data: NonReadonly<PatchedRating> },
		TContext
	>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof courseRatingUpdate>>,
	TError,
	{ courseId: string; ratingId: string; data: NonReadonly<PatchedRating> },
	TContext
> => {
	const mutationKey = ["courseRatingUpdate"];
	const { mutation: mutationOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof courseRatingUpdate>>,
		{ courseId: string; ratingId: string; data: NonReadonly<PatchedRating> }
	> = (props) => {
		const { courseId, ratingId, data } = props ?? {};

		return courseRatingUpdate(courseId, ratingId, data);
	};

	return { mutationFn, ...mutationOptions };
};

export type CourseRatingUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof courseRatingUpdate>>
>;
export type CourseRatingUpdateMutationBody = NonReadonly<PatchedRating>;
export type CourseRatingUpdateMutationError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

/**
 * @summary Update rating for a course (mock)
 */
export const useCourseRatingUpdate = <
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof courseRatingUpdate>>,
			TError,
			{ courseId: string; ratingId: string; data: NonReadonly<PatchedRating> },
			TContext
		>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof courseRatingUpdate>>,
	TError,
	{ courseId: string; ratingId: string; data: NonReadonly<PatchedRating> },
	TContext
> => {
	const mutationOptions = getCourseRatingUpdateMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};

/**
 * @summary Delete rating for a course (mock)
 */
export const courseRatingDelete = (courseId: string, ratingId: string) => {
	return authorizedFetcher<void>({
		url: `/api/v1/courses/${courseId}/ratings/${ratingId}/`,
		method: "DELETE",
	});
};

export const getCourseRatingDeleteMutationOptions = <
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof courseRatingDelete>>,
		TError,
		{ courseId: string; ratingId: string },
		TContext
	>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof courseRatingDelete>>,
	TError,
	{ courseId: string; ratingId: string },
	TContext
> => {
	const mutationKey = ["courseRatingDelete"];
	const { mutation: mutationOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof courseRatingDelete>>,
		{ courseId: string; ratingId: string }
	> = (props) => {
		const { courseId, ratingId } = props ?? {};

		return courseRatingDelete(courseId, ratingId);
	};

	return { mutationFn, ...mutationOptions };
};

export type CourseRatingDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof courseRatingDelete>>
>;

export type CourseRatingDeleteMutationError =
	| ErrorEnvelope
	| ErrorEnvelope
	| ErrorEnvelope;

/**
 * @summary Delete rating for a course (mock)
 */
export const useCourseRatingDelete = <
	TError = ErrorEnvelope | ErrorEnvelope | ErrorEnvelope,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof courseRatingDelete>>,
			TError,
			{ courseId: string; ratingId: string },
			TContext
		>;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof courseRatingDelete>>,
	TError,
	{ courseId: string; ratingId: string },
	TContext
> => {
	const mutationOptions = getCourseRatingDeleteMutationOptions(options);

	return useMutation(mutationOptions, queryClient);
};
