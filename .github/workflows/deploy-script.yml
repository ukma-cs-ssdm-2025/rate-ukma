---
name: Deploy Script

on:
  workflow_call:
    inputs:
      version_tag:
        required: true
        type: string
        description: "The version tag to deploy (will find best matching image)"
      environment:
        required: true
        type: string
        description: "Environment to deploy to (staging or live)"
      archive_name:
        required: true
        type: string
      deployment_ref:
        description: "Commit SHA, Tag, or Branch to checkout. Defaults to the workflow run commit."
        required: false
        type: string
        default: ""
      test_url:
        description: "URL to run e2e tests against after deployment"
        required: false
        type: string
      run_e2e_tests:
        description: "Whether to run e2e tests after deployment"
        required: false
        type: boolean
        default: false
    secrets:
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_KEY:
        required: true
      CORPORATE_EMAIL:
        required: true
      CORPORATE_PASSWORD:
        required: true

env:
  PROJECT_DIR: /opt/rateukma
  PROJECT_SOURCE_CODE: /opt/rateukma/src
  REMOTE_TMP_DEPLOY_DIR: /tmp/deploy
  REMOTE_BACKUP_CODE_DIR: /tmp/deploy/src-backup
  STATIC_ROOT: /opt/rateukma/static
  MAX_ATTEMPTS: 6
  SERVICES_HEALTHCHECK_TIMEOUT: 10

concurrency:
  group: deploy-${{ github.workflow }} # main-pipeline or prod-pipeline

jobs:
  deploy:
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: read

    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.deployment_ref || github.sha }}

      - name: Find latest available image tags
        id: find-tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_VERSION: ${{ inputs.version_tag }}
          ENVIRONMENT: ${{ inputs.environment }}
          ORG: ${{ github.repository_owner }}
        run: |
          # Determine webapp prefix based on environment
          if [ "$ENVIRONMENT" = "staging" ]; then
            WEBAPP_PREFIX="staging-"
          elif [ "$ENVIRONMENT" = "live" ]; then
            WEBAPP_PREFIX="live-"
          else
            echo "Unknown environment: $ENVIRONMENT" >&2
            exit 1
          fi

          BACKEND_TAG=$(bash scripts/ci/find-image-tags.sh "rate-ukma/backend" "$TARGET_VERSION" "")
          WEBAPP_TAG=$(bash scripts/ci/find-image-tags.sh "rate-ukma/webapp" "$TARGET_VERSION" "$WEBAPP_PREFIX")

          echo "backend_tag=$BACKEND_TAG" >> "$GITHUB_OUTPUT"
          echo "webapp_tag=$WEBAPP_TAG" >> "$GITHUB_OUTPUT"

          echo "### Selected Image Tags" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Backend**: \`$BACKEND_TAG\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Webapp**: \`$WEBAPP_TAG\`" >> "$GITHUB_STEP_SUMMARY"

      - name: Set environment variables
        env:
          ARCHIVE_NAME: ${{ inputs.archive_name }}
        run: |
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV

      - name: Create deployment archive
        run: |
          tar -czf ${{ env.ARCHIVE_NAME }} src/ docs/api/openapi-generated.yaml

      - name: Upload archive to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          source: ${{ env.ARCHIVE_NAME }}
          target: ${{ env.REMOTE_TMP_DEPLOY_DIR }}/

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        env:
          BACKEND_IMAGE_TAG: ${{ steps.find-tags.outputs.backend_tag }}
          WEBAPP_IMAGE_TAG: ${{ steps.find-tags.outputs.webapp_tag }}
          ENVIRONMENT: ${{ inputs.environment }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          command_timeout: "30m"
          envs: BACKEND_IMAGE_TAG,WEBAPP_IMAGE_TAG,ENVIRONMENT
          script: |
            set -euo pipefail

            PROJECT_DIR="${{ env.PROJECT_DIR }}"
            SOURCE_CODE="${{ env.PROJECT_SOURCE_CODE }}"
            TMP_DIR="${{ env.REMOTE_TMP_DEPLOY_DIR }}"
            BACKUP_DIR="${{ env.REMOTE_BACKUP_CODE_DIR }}"
            STATIC_ROOT="${{ env.STATIC_ROOT }}"
            ARCHIVE="${{ env.ARCHIVE_NAME }}"
            MAX_ATTEMPTS="${{ env.MAX_ATTEMPTS }}"
            HEALTHCHECK_TIMEOUT="${{ env.SERVICES_HEALTHCHECK_TIMEOUT }}"
            SSH_USER="${{ secrets.SSH_USER }}"
            GITHUB_TOKEN="${{ secrets.GITHUB_TOKEN }}"
            GITHUB_ACTOR="${{ github.actor }}"

            PREV_WEBAPP_TAG=""
            PREV_BACKEND_TAG=""

            compose_cmd() {
              sudo WEBAPP_IMAGE_TAG="$1" BACKEND_IMAGE_TAG="$2" docker compose --profile prod "$3"
            }

            setup_permissions() {
              echo "Setting up directory permissions..."
              sudo chown -R "$SSH_USER:$SSH_USER" "$PROJECT_DIR"
              sudo chmod -R 755 "$PROJECT_DIR"
              sudo chown -R "$SSH_USER:$SSH_USER" "$TMP_DIR"
              sudo chmod -R 755 "$TMP_DIR"
            }

            backup_current_version() {
              echo "Creating backup of current version..."
              mkdir -p "$TMP_DIR" "$BACKUP_DIR"

              if [ ! -d "$SOURCE_CODE" ]; then
                return
              fi

              cp -r "$SOURCE_CODE" "$BACKUP_DIR/"
              echo "Backup created at $BACKUP_DIR"

              echo "Saving current image tags for potential rollback..."
              cd "$SOURCE_CODE"
              PREV_WEBAPP_TAG=$(sudo docker ps --format "{{.Image}}" | grep "webapp" | awk -F: '{print $2}' || echo "")
              PREV_BACKEND_TAG=$(sudo docker ps --format "{{.Image}}" | grep "backend" | awk -F: '{print $2}' || echo "")

              echo "Previous WEBAPP_IMAGE_TAG: $PREV_WEBAPP_TAG"
              echo "Previous BACKEND_IMAGE_TAG: $PREV_BACKEND_TAG"
              echo "PREV_WEBAPP_TAG=$PREV_WEBAPP_TAG" > "$TMP_DIR/prev_tags.env"
              echo "PREV_BACKEND_TAG=$PREV_BACKEND_TAG" >> "$TMP_DIR/prev_tags.env"
            }

            stop_services() {
              echo "Stopping existing services..."
              cd "$SOURCE_CODE"
              if [ -n "$PREV_WEBAPP_TAG" ] && [ -n "$PREV_BACKEND_TAG" ]; then
                compose_cmd "$PREV_WEBAPP_TAG" "$PREV_BACKEND_TAG" "down" || true
              else
                sudo docker compose --profile prod down || true
              fi
            }

            deploy_new_version() {
              echo "Cleaning project directory..."
              rm -rf "$SOURCE_CODE"/*

              echo "Extracting new version..."
              cd "$PROJECT_DIR"
              if ! tar xzf "$TMP_DIR/$ARCHIVE"; then
                echo "Failed to extract archive"
                return 1
              fi
              rm "$TMP_DIR/$ARCHIVE"

              echo "Copying environment file..."
              cp "$PROJECT_DIR/.env" "$SOURCE_CODE/.env"

              echo "Logging in to GitHub Container Registry..."
              if ! echo "$GITHUB_TOKEN" | sudo docker login ghcr.io -u "$GITHUB_ACTOR" --password-stdin; then
                echo "Docker login failed"
                return 1
              fi

              echo "Pulling docker images..."
              echo "Using WEBAPP_IMAGE_TAG: $WEBAPP_IMAGE_TAG"
              echo "Using BACKEND_IMAGE_TAG: $BACKEND_IMAGE_TAG"
              cd "$SOURCE_CODE"
              compose_cmd "$WEBAPP_IMAGE_TAG" "$BACKEND_IMAGE_TAG" "pull"

              echo "Starting services..."
              compose_cmd "$WEBAPP_IMAGE_TAG" "$BACKEND_IMAGE_TAG" "up -d"
            }

            health_check() {
              echo "Waiting for services to be up and running..."
              local attempt=1

              EXPECTED_SERVICES=$(sudo docker compose --profile prod config --services | wc -l)
              echo "Expecting $EXPECTED_SERVICES services"

              while [ "$attempt" -le "$MAX_ATTEMPTS" ]; do
                echo "Health check attempt $attempt/$MAX_ATTEMPTS..."

                RUNNING_SERVICES=$(sudo docker compose ps --status=running --format json | jq -s 'length')

                if [ "$RUNNING_SERVICES" -eq "$EXPECTED_SERVICES" ] && [ -f "$STATIC_ROOT/index.html" ]; then
                  return 0
                fi

                echo "Services not ready yet ($RUNNING_SERVICES/$EXPECTED_SERVICES running), waiting..."
                sleep "$HEALTHCHECK_TIMEOUT"
                attempt=$((attempt + 1))
              done

              return 1
            }

            cleanup_on_success() {
              echo "Services are up and healthy"
              rm -rf "$BACKUP_DIR"
              rm -f "$TMP_DIR/prev_tags.env"

              echo "Cleaning up old Docker resources (older than 7 days)..."
              sudo docker image prune -a -f --filter "until=168h"
              sudo docker container prune -f --filter "until=168h"
              sudo docker network prune -f

              echo "Reclaimed space:"
              sudo docker system df
              echo "Deployment successful"
            }

            rollback() {
              echo "Services failed to start properly. Rolling back..."
              sudo docker compose --profile prod down || true

              echo "Restoring previous version from $BACKUP_DIR"
              rm -rf "$SOURCE_CODE"/*
              cp -r "$BACKUP_DIR/src/"* "$SOURCE_CODE/"

              cd "$SOURCE_CODE"

              if [ -f "$TMP_DIR/prev_tags.env" ]; then
                echo "Loading previous image tags..."
                source "$TMP_DIR/prev_tags.env"
                echo "Rolling back to WEBAPP: $PREV_WEBAPP_TAG, BACKEND: $PREV_BACKEND_TAG"

                compose_cmd "$PREV_WEBAPP_TAG" "$PREV_BACKEND_TAG" "pull"
                compose_cmd "$PREV_WEBAPP_TAG" "$PREV_BACKEND_TAG" "up -d"
              else
                echo "Warning: Previous tags not found. Attempting basic rollback..."
                sudo docker compose --profile prod pull
                sudo docker compose --profile prod up -d
              fi

              echo "Rollback completed. Deployment failed."
              exit 1
            }

            # --- Main deployment flow ---
            echo "Deploying..."
            setup_permissions
            backup_current_version
            stop_services
            deploy_new_version

            if health_check; then
              cleanup_on_success
            else
              rollback
            fi

  warmup:
    needs: deploy
    runs-on: ubuntu-24.04
    steps:
      - name: Run warmup backend command
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          command_timeout: "30m"
          script: |
            backend_container=$(docker ps --format "{{.Names}}" | grep backend)
            if [ -z "$backend_container" ]; then
              echo "Backend running container is not found"
              exit 1
            fi

            if ! docker exec $backend_container uv run python manage.py warmup; then
              echo "Warmup failed"
              exit 1
            fi

            echo "Warmup completed"

  e2e-test:
    if: inputs.run_e2e_tests && inputs.test_url != ''
    needs: warmup
    uses: ./.github/workflows/e2e-test.yml
    with:
      test_url: ${{ inputs.test_url }}
      deployment_ref: ${{ inputs.deployment_ref }}
    secrets:
      CORPORATE_EMAIL: ${{ secrets.CORPORATE_EMAIL }}
      CORPORATE_PASSWORD: ${{ secrets.CORPORATE_PASSWORD }}
