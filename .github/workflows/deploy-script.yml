---
name: Deploy Script

on:
  workflow_call:
    inputs:
      version_tag:
        required: true
        type: string
        description: "The version tag to deploy (will find best matching image)"
      environment:
        required: true
        type: string
        description: "Environment to deploy to (staging or live)"
      archive_name:
        required: true
        type: string
      deployment_ref:
        description: "Commit SHA, Tag, or Branch to checkout. Defaults to the workflow run commit."
        required: false
        type: string
        default: ""
      test_url:
        description: "URL to run e2e tests against after deployment"
        required: false
        type: string
      run_e2e_tests:
        description: "Whether to run e2e tests after deployment"
        required: false
        type: boolean
        default: false
    secrets:
      SSH_HOST:
        required: true
      SSH_USER:
        required: true
      SSH_KEY:
        required: true
      CORPORATE_EMAIL:
        required: true
      CORPORATE_PASSWORD:
        required: true

env:
  PROJECT_DIR: /opt/rateukma
  PROJECT_SOURCE_CODE: /opt/rateukma/src
  REMOTE_TMP_DEPLOY_DIR: /tmp/deploy
  REMOTE_BACKUP_CODE_DIR: /tmp/deploy/src-backup
  STATIC_ROOT: /opt/rateukma/static
  MAX_ATTEMPTS: 6
  SERVICES_HEALTHCHECK_TIMEOUT: 10

concurrency:
  group: deploy-${{ github.workflow }} # main-pipeline or prod-pipeline

jobs:
  deploy:
    runs-on: ubuntu-24.04
    permissions:
      contents: read
      packages: read

    steps:
      - uses: actions/checkout@v5
        with:
          ref: ${{ inputs.deployment_ref || github.sha }}

      - name: Find latest available image tags
        id: find-tags
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TARGET_VERSION: ${{ inputs.version_tag }}
          ENVIRONMENT: ${{ inputs.environment }}
          ORG: ${{ github.repository_owner }}
        run: |
          find_latest_version() {
            local package_name=$1
            local target_version=$2
            local tag_prefix=$3

            echo "Searching for $package_name (target: $target_version, prefix: $tag_prefix)" >&2

            local encoded_package="${package_name//\//%2F}"
            local tags=$(gh api \
              -H "Accept: application/vnd.github+json" \
              -H "X-GitHub-Api-Version: 2022-11-28" \
              --paginate \
              "/orgs/$ORG/packages/container/$encoded_package/versions" \
              --jq '[.[] | .metadata.container.tags[]? // empty] | unique | .[]')

            if [ -z "$tags" ]; then
              echo "No tags found, using default: ${tag_prefix}${target_version}" >&2
              echo "${tag_prefix}${target_version}"
              return
            fi

            # Filter tags matching the pattern
            local pattern="^${tag_prefix}v[0-9]+\.[0-9]+\.[0-9]+"
            local filtered=$(echo "$tags" | grep -E "$pattern" || true)

            if [ -z "$filtered" ]; then
              echo "No matching tags found, using default: ${tag_prefix}${target_version}" >&2
              echo "${tag_prefix}${target_version}"
              return
            fi

            # Remove prefix and 'v' for version comparison
            local target_num="${target_version#v}"

            # Find highest version <= target
            local latest=$(echo "$filtered" | while IFS= read -r tag; do
              local ver="${tag#$tag_prefix}"
              ver="${ver#v}"

              # Compare versions: if ver <= target_num, output it
              if [ "$(printf '%s\n' "$ver" "$target_num" | sort -V | tail -n1)" = "$target_num" ]; then
                echo "$tag"
              fi
            done | sort -V | tail -n1)

            if [ -n "$latest" ]; then
              echo "Found: $latest" >&2
              echo "$latest"
            else
              echo "No suitable version found, using default: ${tag_prefix}${target_version}" >&2
              echo "${tag_prefix}${target_version}"
            fi
          }

          # Determine webapp prefix based on environment
          if [ "$ENVIRONMENT" = "staging" ]; then
            WEBAPP_PREFIX="staging-"
          elif [ "$ENVIRONMENT" = "live" ]; then
            WEBAPP_PREFIX="live-"
          else
            echo "Unknown environment: $ENVIRONMENT" >&2
            exit 1
          fi

          # Find versions
          BACKEND_TAG=$(find_latest_version "rate-ukma/backend" "$TARGET_VERSION" "")
          WEBAPP_TAG=$(find_latest_version "rate-ukma/webapp" "$TARGET_VERSION" "$WEBAPP_PREFIX")

          echo "backend_tag=$BACKEND_TAG" >> "$GITHUB_OUTPUT"
          echo "webapp_tag=$WEBAPP_TAG" >> "$GITHUB_OUTPUT"

          # Summary
          echo "### Selected Image Tags" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Backend**: \`$BACKEND_TAG\`" >> "$GITHUB_STEP_SUMMARY"
          echo "- **Webapp**: \`$WEBAPP_TAG\`" >> "$GITHUB_STEP_SUMMARY"

      - name: Set environment variables
        env:
          ARCHIVE_NAME: ${{ inputs.archive_name }}
        run: |
          echo "ARCHIVE_NAME=$ARCHIVE_NAME" >> $GITHUB_ENV

      - name: Create deployment archive
        run: |
          tar -czf ${{ env.ARCHIVE_NAME }} src/ docs/api/openapi-generated.yaml

      - name: Upload archive to server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          source: ${{ env.ARCHIVE_NAME }}
          target: ${{ env.REMOTE_TMP_DEPLOY_DIR }}/

      - name: Deploy to server
        uses: appleboy/ssh-action@master
        env:
          BACKEND_IMAGE_TAG: ${{ steps.find-tags.outputs.backend_tag }}
          WEBAPP_IMAGE_TAG: ${{ steps.find-tags.outputs.webapp_tag }}
          ENVIRONMENT: ${{ inputs.environment }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          command_timeout: "30m"
          envs: BACKEND_IMAGE_TAG,WEBAPP_IMAGE_TAG,ENVIRONMENT
          script: |
            echo "Deploying..."

            echo "Setting up project directory ownership..."
            sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} ${{ env.PROJECT_DIR }}
            sudo chmod -R 755 ${{ env.PROJECT_DIR }}

            echo "Setting up tmp deploy directory ownership..."
            sudo chown -R ${{ secrets.SSH_USER }}:${{ secrets.SSH_USER }} ${{ env.REMOTE_TMP_DEPLOY_DIR }}
            sudo chmod -R 755 ${{ env.REMOTE_TMP_DEPLOY_DIR }}

            echo "Creating backup of current version..."

            mkdir -p "${{ env.REMOTE_TMP_DEPLOY_DIR }}"
            mkdir -p "${{ env.REMOTE_BACKUP_CODE_DIR }}"

            PREV_WEBAPP_TAG=""
            PREV_BACKEND_TAG=""

            if [ -d "${{ env.PROJECT_SOURCE_CODE }}" ]; then
              echo "Backing up current source code..."
              cp -r ${{ env.PROJECT_SOURCE_CODE }} "${{ env.REMOTE_BACKUP_CODE_DIR }}/"
              echo "Backup created at ${{ env.REMOTE_BACKUP_CODE_DIR }}"

              echo "Saving current image tags for potential rollback..."
              cd ${{ env.PROJECT_SOURCE_CODE }}

              # Get current image tags
              if [ -z "$PREV_WEBAPP_TAG" ]; then
                WEBAPP_PATTERN="webapp.*$ENVIRONMENT-"
                PREV_WEBAPP_TAG=$(sudo docker ps --format "{{.Image}}" | grep "webapp" | awk -F: '{print $2}' || echo "")
              fi
              if [ -z "$PREV_BACKEND_TAG" ]; then
                PREV_BACKEND_TAG=$(sudo docker ps --format "{{.Image}}" | grep "backend" | awk -F: '{print $2}' || echo "")

              fi

              echo "Previous WEBAPP_IMAGE_TAG: $PREV_WEBAPP_TAG"
              echo "Previous BACKEND_IMAGE_TAG: $PREV_BACKEND_TAG"
              echo "PREV_WEBAPP_TAG=$PREV_WEBAPP_TAG" > "${{ env.REMOTE_TMP_DEPLOY_DIR }}/prev_tags.env"
              echo "PREV_BACKEND_TAG=$PREV_BACKEND_TAG" >> "${{ env.REMOTE_TMP_DEPLOY_DIR }}/prev_tags.env"
            fi

            echo "Stopping existing services..."
            cd ${{ env.PROJECT_SOURCE_CODE }}
            if [ -n "$PREV_WEBAPP_TAG" ] && [ -n "$PREV_BACKEND_TAG" ]; then
              sudo WEBAPP_IMAGE_TAG=$PREV_WEBAPP_TAG BACKEND_IMAGE_TAG=$PREV_BACKEND_TAG docker compose --profile prod down || true
            else
              sudo docker compose --profile prod down || true
            fi

            echo "Cleaning project directory..."
            rm -rf ${{ env.PROJECT_SOURCE_CODE }}/*

            echo "Extracting new version..."
            cd ${{ env.PROJECT_DIR }}
            if ! tar xzf ${{ env.REMOTE_TMP_DEPLOY_DIR }}/${{ env.ARCHIVE_NAME }}; then
              echo "Failed to extract archive"
              exit 1
            fi
            rm ${{ env.REMOTE_TMP_DEPLOY_DIR }}/${{ env.ARCHIVE_NAME }}

            echo "Copying environment file..."
            cp ${{ env.PROJECT_DIR }}/.env ${{ env.PROJECT_SOURCE_CODE }}/.env

            echo "Logging in to GitHub Container Registry..."
            if ! echo "$GITHUB_TOKEN" | sudo docker login ghcr.io -u ${{ github.actor }} --password-stdin; then
              echo "Docker login failed"
              exit 1
            fi

            echo "Pulling docker images..."
            echo "Using WEBAPP_IMAGE_TAG: $WEBAPP_IMAGE_TAG"
            echo "Using BACKEND_IMAGE_TAG: $BACKEND_IMAGE_TAG"
            cd ${{ env.PROJECT_SOURCE_CODE }}
            sudo WEBAPP_IMAGE_TAG=$WEBAPP_IMAGE_TAG BACKEND_IMAGE_TAG=$BACKEND_IMAGE_TAG docker compose --profile prod pull

            echo "Starting services with pulled images..."
            sudo WEBAPP_IMAGE_TAG=$WEBAPP_IMAGE_TAG BACKEND_IMAGE_TAG=$BACKEND_IMAGE_TAG docker compose --profile prod up -d

            echo "Waiting for services to be up and running..."
            max_attempts=${{ env.MAX_ATTEMPTS }}
            attempt=1
            services_healthy=false

            while [ $attempt -le $max_attempts ]; do
              echo "Up and running check attempt $attempt/$max_attempts..."

              EXPECTED_SERVICES=3
              RUNNING_SERVICES=$(sudo docker compose ps --status=running --format json | jq -s 'length')

              if [ "$RUNNING_SERVICES" -eq "$EXPECTED_SERVICES" ] && \
                  [ -f ${{ env.STATIC_ROOT }}/index.html ]; then
                services_healthy=true
                break
              fi

              echo "Services not ready yet, waiting..."
              sleep ${{ env.SERVICES_HEALTHCHECK_TIMEOUT }}
              attempt=$((attempt + 1))
            done

            if [ "$services_healthy" = true ]; then
              echo "Services are up and healthy"
              echo "Cleaning up backup directory..."
              rm -rf "${{ env.REMOTE_BACKUP_CODE_DIR }}"
              rm -f "${{ env.REMOTE_TMP_DEPLOY_DIR }}/prev_tags.env"
              echo "Deployment finished successfully"


              echo "Deployment successful, cleaning up old images for the last 7 days..."
              sudo docker image prune -a -f --filter "until=168h"
              sudo docker container prune -f --filter "until=168h"

              echo "Cleaning up unused networks..."
              sudo docker network prune -f

              echo "Reclaimed space:"
              sudo docker system df

              echo "Deployment successful"

            else
              echo "Services failed to start properly. Rolling back..."
              sudo docker compose --profile prod down || true

              echo "Restoring previous version from ${{ env.REMOTE_BACKUP_CODE_DIR }}"
              rm -rf ${{ env.PROJECT_SOURCE_CODE }}/*
              cp -r "${{ env.REMOTE_BACKUP_CODE_DIR }}/src/"* ${{ env.PROJECT_SOURCE_CODE }}/

              cd ${{ env.PROJECT_SOURCE_CODE }}

              if [ -f "${{ env.REMOTE_TMP_DEPLOY_DIR }}/prev_tags.env" ]; then
                echo "Loading previous image tags..."
                source "${{ env.REMOTE_TMP_DEPLOY_DIR }}/prev_tags.env"
                echo "Rolling back to WEBAPP_IMAGE_TAG: $PREV_WEBAPP_TAG"
                echo "Rolling back to BACKEND_IMAGE_TAG: $PREV_BACKEND_TAG"

                echo "Pulling previous docker images..."
                sudo WEBAPP_IMAGE_TAG=$PREV_WEBAPP_TAG BACKEND_IMAGE_TAG=$PREV_BACKEND_TAG docker compose --profile prod pull

                echo "Starting previous version..."
                sudo WEBAPP_IMAGE_TAG=$PREV_WEBAPP_TAG BACKEND_IMAGE_TAG=$PREV_BACKEND_TAG docker compose --profile prod up -d
              else
                echo "Warning: Previous tags not found. Attempting basic rollback..."
                sudo docker compose --profile prod pull
                sudo docker compose --profile prod up -d
              fi

              echo "Rollback completed. Deployment failed."
              exit 1
            fi

  warmup:
    needs: deploy
    runs-on: ubuntu-24.04
    steps:
      - name: Run warmup backend command
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          command_timeout: "30m"
          script: |
            backend_container=$(docker ps --format "{{.Names}}" | grep backend)
            if [ -z "$backend_container" ]; then
              echo "Backend running container is not found"
              exit 1
            fi

            if ! docker exec $backend_container uv run python manage.py warmup; then
              echo "Warmup failed"
              exit 1
            fi

            echo "Warmup completed"

  e2e-test:
    if: inputs.run_e2e_tests && inputs.test_url != ''
    needs: warmup
    uses: ./.github/workflows/e2e-test.yml
    with:
      test_url: ${{ inputs.test_url }}
      deployment_ref: ${{ inputs.deployment_ref }}
    secrets:
      CORPORATE_EMAIL: ${{ secrets.CORPORATE_EMAIL }}
      CORPORATE_PASSWORD: ${{ secrets.CORPORATE_PASSWORD }}
